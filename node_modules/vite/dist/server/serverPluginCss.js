"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const hash_sum_1 = __importDefault(require("hash-sum"));
const utils_1 = require("../utils");
const serverPluginVue_1 = require("./serverPluginVue");
const cssUtils_1 = require("../utils/cssUtils");
const querystring_1 = __importDefault(require("querystring"));
const chalk_1 = __importDefault(require("chalk"));
exports.debugCSS = require('debug')('vite:css');
const processedCSS = new Map();
exports.cssPlugin = ({ root, app, watcher, resolver }) => {
    app.use(async (ctx, next) => {
        await next();
        // handle .css imports
        if (cssUtils_1.isCSSRequest(ctx.path) &&
            // note ctx.body could be null if upstream set status to 304
            ctx.body) {
            const id = JSON.stringify(hash_sum_1.default(ctx.path));
            if (utils_1.isImportRequest(ctx)) {
                await processCss(root, ctx);
                // we rewrite css with `?import` to a js module that inserts a style
                // tag linking to the actual raw url
                ctx.type = 'js';
                const { css, modules } = processedCSS.get(ctx.path);
                ctx.body = cssUtils_1.codegenCss(id, css, modules);
            }
            else {
                // raw request, return compiled css
                if (!processedCSS.has(ctx.path)) {
                    await processCss(root, ctx);
                }
                ctx.type = 'css';
                ctx.body = processedCSS.get(ctx.path).css;
            }
        }
    });
    watcher.on('change', (filePath) => {
        if (cssUtils_1.isCSSRequest(filePath)) {
            const publicPath = resolver.fileToRequest(filePath);
            /** filter unused files */
            if (!cssUtils_1.cssImportMap.has(filePath) &&
                !processedCSS.has(publicPath) &&
                !serverPluginVue_1.srcImportMap.has(filePath)) {
                return exports.debugCSS(`${path_1.basename(publicPath)} has changed, but it is not currently in use`);
            }
            if (serverPluginVue_1.srcImportMap.has(filePath)) {
                // handle HMR for <style src="xxx.css">
                // it cannot be handled as simple css import because it may be scoped
                const styleImport = serverPluginVue_1.srcImportMap.get(filePath);
                serverPluginVue_1.vueCache.del(filePath);
                vueStyleUpdate(styleImport);
                return;
            }
            // handle HMR for module.css
            // it cannot be handled as normal css because the js exports may change
            if (filePath.endsWith('.module.css')) {
                moduleCssUpdate(filePath, resolver);
            }
            const boundaries = cssUtils_1.getCssImportBoundaries(filePath);
            if (boundaries.size) {
                for (let boundary of boundaries) {
                    if (boundary.includes('.module')) {
                        moduleCssUpdate(boundary, resolver);
                    }
                    else if (boundary.includes('.vue')) {
                        serverPluginVue_1.vueCache.del(utils_1.cleanUrl(boundary));
                        vueStyleUpdate(resolver.fileToRequest(boundary));
                    }
                    else {
                        normalCssUpdate(resolver.fileToRequest(boundary));
                    }
                }
                return;
            }
            // no boundaries
            normalCssUpdate(publicPath);
        }
    });
    function vueStyleUpdate(styleImport) {
        const publicPath = utils_1.cleanUrl(styleImport);
        const index = querystring_1.default.parse(styleImport.split('?', 2)[1]).index;
        console.log(chalk_1.default.green(`[vite:hmr] `) + `${publicPath} updated. (style)`);
        watcher.send({
            type: 'style-update',
            path: `${publicPath}?type=style&index=${index}`,
            timestamp: Date.now()
        });
    }
    function moduleCssUpdate(filePath, resolver) {
        // bust process cache
        processedCSS.delete(resolver.fileToRequest(filePath));
        watcher.handleJSReload(filePath);
    }
    function normalCssUpdate(publicPath) {
        // bust process cache
        processedCSS.delete(publicPath);
        watcher.send({
            type: 'style-update',
            path: publicPath,
            timestamp: Date.now()
        });
    }
    async function processCss(root, ctx) {
        // source didn't change (marker added by cachedRead)
        // just use previously cached result
        if (ctx.__notModified && processedCSS.has(ctx.path)) {
            return;
        }
        const css = (await utils_1.readBody(ctx.body));
        const result = await cssUtils_1.compileCss(root, ctx.path, {
            id: '',
            source: css,
            filename: resolver.requestToFile(ctx.path),
            scoped: false,
            modules: ctx.path.includes('.module'),
            preprocessLang: ctx.path.replace(cssUtils_1.cssPreprocessLangRE, '$2'),
            preprocessOptions: ctx.config.cssPreprocessOptions
        });
        if (typeof result === 'string') {
            processedCSS.set(ctx.path, { css: await cssUtils_1.rewriteCssUrls(css, ctx.path) });
            return;
        }
        if (result.errors.length) {
            console.error(`[vite] error applying css transforms: `);
            result.errors.forEach(console.error);
        }
        result.code = await cssUtils_1.rewriteCssUrls(result.code, ctx.path);
        processedCSS.set(ctx.path, {
            css: result.code,
            modules: result.modules
        });
    }
};
//# sourceMappingURL=serverPluginCss.js.map